<polymer-element name="x-menu" extends="div" tabindex="0" attributes="items">
	<template>
		<style>
		:host {
			box-shadow: 3px 3px 5px 1px #ccc;
			border: 1px solid #a1a1a1;
			color: #000000;
			display: inline-block;
			min-width:15em;
			position:relative;
			/*bottom: 2em;
			right: 2em;*/
			background-color:white;
			width:100px;
			border-radius: 0.8em;
			overflow:hidden;
			z-index: 100;
		}
		.selected {
			border-color:orange;
			outline: none;
			box-shadow: 0 0 10px orange;
			background-color: orange;
		}
		.hidden {
			width: 0px;
			height: 0px;
			visibility:hidden;
			display:none;
			overflow:hidden;
		}
		.title {
			background: linear-gradient(to bottom, #cdd2d8 8%,#989a9b 100%); /* W3C */
			text-shadow:#CECECE 0px 1px 0, #000 0 -1px 0;
			font-weight:bold;
			font-size:0.8em;
			color: #757575;
			padding-left:1em;
		}
		.title span {
			position:absolute;
			top:0px;
			right:1em; 
		}
		</style>
		<div class="title">Menu <span>pag.{{page}}/{{pages}}</span></div>
		<div id="items"></div>
		</template>
	<script>
//NOTE: this.shadowRoot.activeElement
	Polymer('x-menu',{
		created: function (){
			console.log('x-menu has been activated')
			
			//if we passed something inside <x-menu></x-menu>
			//we use it to generate the actual menu into the shadowDOM
			if(this.innerHTML!=''){
				setTimeout(function (){
					this.$.items.innerHTML = this.innerHTML;
					this.createMenu (this.$.items.children);
				}.bind(this), 10);
			}
			
			//set the focus on us //we need to delay it a bit to be sure it works
			setTimeout(function (){
					this.focus();
			}.bind(this), 10);
			
			//manage keyboard events
			$(this).keydown(function(event) {
				console.log(event.which);
				switch (event.which){
					case 38: this.prev();break; //up
					case 40: this.next();break; //down
					case 33: this.selectFirstOfThePage();break; //pgup
					case 34: this.selectLastOfThePage();break; //pgdown
					case 13: this.confirm(); break; //enter
					case 27: this.cancel(); break; //esc
				}
			});
		},

		confirm : function (){
			//remove me from the dom
			this.parentNode.removeChild(this);
			//and return the value
			return this.getSelection();
		},
		cancel : function (){
			//remove me from the dom without returning any value
			this.parentNode.removeChild(this);
		},
		
		createMenu : function (list){
			this.elementsPerPage=10;
console.log('Creating the menu');
			//console.log('STO CREANDO LA TABELLA')
			for (var i=0; i < list.length; i++){
console.log('item done:', i)
				//assign for each item an unique id
				list[i].id = 'element'+i;
			}

			//seleziona una riga della tabella
			this.select = function (id){
				//deseleziona vecchio elemento
				if (this.selected != null){
					this.$.items.querySelector('#element'+this.selected).classList.toggle('selected');
				}
			
				//nascondo la vecchia pagina
				this.hidePage(this.getCurPage());

				//mostro la nuova
				this.page = this.getPageOfTheElement(id);
				this.pages = this.getPagesNumber();
				this.showPage(this.page);
				

				//seleziona il nuovo elemento
				this.$.items.querySelector('#element'+id).classList.toggle('selected');
				
				//ricordo la selezione
				this.selected = id;
				
				//give the new element the focus
				this.$.items.querySelector('#element'+this.selected).focus();
			};
			this.prev = function (){
				console.log('select prev');
				if (this.selected > 0){
					this.select ( this.selected-1);
				}
			};
			this.next = function (){
				console.log('select prev');
				if (this.selected < (list.length-1)){
					this.select ( this.selected+1);
				}
			};
			this.first = function (){
				this.select(0);
			};
			this.last = function (){
				this.select(list.length);
			};
			this.selectFirstOfThePage = function (page){
				this.select(this.getFirstOfThePage(page));
			};
			this.selectLastOfThePage = function (page){
				//console.log('selecting: '+element);
				this.select(this.getLastOfThePage(page));
			};
			this.getSelection = function (){
				//return the current selected object
				return this.list[this.selected];
			};
			this.getLastOfThePage = function (page){
				if(!page){page=this.getCurPage()-1}else{page=page-1;}
				if((this.elementsPerPage-1) > list.length){pageElement=list.length-1}else{pageElement=this.elementsPerPage-1 }
				var element = (page * this.elementsPerPage) + pageElement;
				return element;
			}

			this.getFirstOfThePage = function (page){
				if(!page){page=this.getCurPage()-1}else{page=page-1;}
				var element = (page * this.elementsPerPage);
				return element;
			}

			this.showPage = function (pageNum){
				var showFrom = ((pageNum-1) * this.elementsPerPage);
				var showTo = pageNum * this.elementsPerPage-1;
				//hide the prev page
				for (var i=showFrom; i <= showTo; i++){
						//console.log('try to show: ' +i);
					if(i >=0 && i <list.length ){
						//console.log('ok');
						this.$.items.querySelector('#element'+i).classList.remove('hidden');
					}
				}
			};
			this.hidePage = function (pageNum){
				var hideFrom = ((pageNum-1) * this.elementsPerPage);
				var hideTo = pageNum * this.elementsPerPage-1;
				//hide the prev page
				for (var i=hideFrom; i <= hideTo; i++){
						//console.log('try to hide: ' +i);
					if(i >=0 && i <list.length ){
						//console.log('ok');
						this.$.items.querySelector('#element'+i).classList.add('hidden');
					}
				}		
			};
			this.getCurPage = function (){
				return parseInt((this.selected | 1)/this.elementsPerPage)+1;
			};
			this.getPagesNumber = function (){
				return parseInt(list.length/this.elementsPerPage)+1;
			};
			this.getPageOfTheElement = function (element){
				return parseInt(element/this.elementsPerPage)+1;
			};
			this.hideAllPages = function (){
				var pages = this.getPagesNumber();
				for (var i=1; i <= pages; i++){
					this.hidePage(i);
				}
			}
			
			//nascondo tutte le pagine
			this.hideAllPages();
			//di default seleziono la prima riga todo bisognerebbe selezionare l'elemento corrente
			this.select(0);
		},
		changedItems:function(){
			console.log('rebuild the menu');
		}
	});
	</script>
</polymer-element>
